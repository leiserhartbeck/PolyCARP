(acceptable_polygon
 (near_poly_edge_TCC1 0
  (near_poly_edge_TCC1-1 nil 3634476669 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (near_poly_edge subtype "acceptable_polygon.next"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (upshot_crosses_edge_TCC1 0
  (upshot_crosses_edge_TCC1-1 nil 3634487032 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (upshot_crosses_edge subtype "2"
    "{i_1: integers.int | booleans.OR(((number_fields.-)(acceptable_polygon.p(acceptable_polygon.next)`x, acceptable_polygon.p(acceptable_polygon.i)`x)) /= 0, reals.>=(i_1, 0))}")))
 (upshot_crosses_edge_def 0
  (upshot_crosses_edge_def-1 nil 3634487135
   ("" (skeep)
    (("" (skoletin)
      (("" (skoletin)
        (("" (expand "upshot_crosses_edge" -1 :assert? none)
          ((""
            (name "tester" "(p(next)`x - p(i)`x) ^ 2 * (p(i)`y - s`y) +
                            (s`x - p(i)`x) * (p(next)`y - p(i)`y) * (p(next)`x - p(i)`x)")
            (("1" (label "td" -1)
              (("1" (copy -1)
                (("1" (hide "td")
                  (("1" (replace -3 :dir rl)
                    (("1" (assert)
                      (("1" (replace -1)
                        (("1" (hide -1)
                          (("1" (lift-if -1)
                            (("1" (assert)
                              (("1"
                                (split -)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (replace -3)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (skosimp*)
                                        (("1"
                                          (case "t!1 = 1")
                                          (("1"
                                            (replace -1)
                                            (("1"
                                              (assert)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (case "t!1 = 0")
                                            (("1"
                                              (replaces -1)
                                              (("1"
                                                (assert)
                                                (("1" (grind) nil nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (mult-by -1 "1-t!1")
                                              (("2"
                                                (mult-by -2 "t!1")
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (split -)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (replace -3)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (skeep)
                                            (("1"
                                              (case "t = 0")
                                              (("1"
                                                (replaces -1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (case "t = 1")
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (mult-by -1 "1-t")
                                                  (("2"
                                                    (mult-by -2 "t")
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (split -)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (case "NOT p(i)`x = s`x")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (ground)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (hide (1 2))
                                                  (("2"
                                                    (split -)
                                                    (("1"
                                                      (inst
                                                       +
                                                       "p(i)`y-s`y"
                                                       "0")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (decompose-equality
                                                           1)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (hide -)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (inst
                                                       +
                                                       "p(next)`y-s`y"
                                                       "1")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (decompose-equality
                                                           +)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (hide -)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split -)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (replace 1)
                                                    (("1"
                                                      (replace -2)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (skeep)
                                                          (("1"
                                                            (case
                                                             "t = 0")
                                                            (("1"
                                                              (replace
                                                               -1)
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (case
                                                               "t = 1")
                                                              (("1"
                                                                (replace
                                                                 -1)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (mult-by
                                                                 3
                                                                 "1-t")
                                                                (("2"
                                                                  (mult-by
                                                                   4
                                                                   "t")
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (hide 2)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (split -)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (replaces -2)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (name
                                                               "tt"
                                                               "(s`x-p(i)`x)/(p(next)`x-p(i)`x)")
                                                              (("1"
                                                                (case
                                                                 "NOT (0<=tt AND tt<=1)")
                                                                (("1"
                                                                  (replaces
                                                                   -1
                                                                   :dir
                                                                   rl)
                                                                  (("1"
                                                                    (split)
                                                                    (("1"
                                                                      (cross-mult
                                                                       1)
                                                                      (("1"
                                                                        (ground)
                                                                        nil
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (cross-mult
                                                                       1)
                                                                      (("2"
                                                                        (ground)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (name
                                                                       "P"
                                                                       "(1 - tt) * p(i) + tt * p(next)")
                                                                      (("2"
                                                                        (case
                                                                         "NOT P`y>=s`y")
                                                                        (("1"
                                                                          (hide
                                                                           (3
                                                                            4))
                                                                          (("1"
                                                                            (hide
                                                                             3)
                                                                            (("1"
                                                                              (expand
                                                                               "P"
                                                                               1)
                                                                              (("1"
                                                                                (reveal
                                                                                 "td")
                                                                                (("1"
                                                                                  (expand
                                                                                   "tt"
                                                                                   1)
                                                                                  (("1"
                                                                                    (replaces
                                                                                     -1
                                                                                     :dir
                                                                                     rl)
                                                                                    (("1"
                                                                                      (mult-by
                                                                                       1
                                                                                       "sq(p(next)`x-p(i)`x)")
                                                                                      (("1"
                                                                                        (both-sides
                                                                                         "-"
                                                                                         "s`y*sq(p(next)`x-p(i)`x)"
                                                                                         1)
                                                                                        (("1"
                                                                                          (assert)
                                                                                          (("1"
                                                                                            (invoke
                                                                                             (case
                                                                                              "%1 = %2")
                                                                                             (!
                                                                                              -5
                                                                                              1)
                                                                                             (!
                                                                                              1
                                                                                              1))
                                                                                            (("1"
                                                                                              (assert)
                                                                                              nil
                                                                                              nil)
                                                                                             ("2"
                                                                                              (hide
                                                                                               (-5
                                                                                                2))
                                                                                              (("2"
                                                                                                (hide
                                                                                                 -5)
                                                                                                (("2"
                                                                                                  (grind)
                                                                                                  (("2"
                                                                                                    (field)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (hide
                                                                                         (-5
                                                                                          2))
                                                                                        (("2"
                                                                                          (lemma
                                                                                           "sq_gt_0")
                                                                                          (("2"
                                                                                            (inst?)
                                                                                            (("2"
                                                                                              (assert)
                                                                                              nil
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (inst
                                                                           +
                                                                           "P`y - s`y"
                                                                           "tt")
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (replace
                                                                               -2)
                                                                              (("1"
                                                                                (case
                                                                                 "P`x = s`x")
                                                                                (("1"
                                                                                  (decompose-equality
                                                                                   4)
                                                                                  (("1"
                                                                                    (grind)
                                                                                    nil
                                                                                    nil)
                                                                                   ("2"
                                                                                    (grind)
                                                                                    nil
                                                                                    nil))
                                                                                  nil)
                                                                                 ("2"
                                                                                  (expand
                                                                                   "P"
                                                                                   +)
                                                                                  (("2"
                                                                                    (expand
                                                                                     "tt"
                                                                                     1)
                                                                                    (("2"
                                                                                      (hide
                                                                                       (3
                                                                                        4
                                                                                        5
                                                                                        -7))
                                                                                      (("2"
                                                                                        (hide
                                                                                         (-1
                                                                                          -2
                                                                                          -3
                                                                                          -4
                                                                                          -5
                                                                                          -6))
                                                                                        (("2"
                                                                                          (grind)
                                                                                          (("2"
                                                                                            (field)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (replaces -1)
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (hide -2)
                                                              (("2"
                                                                (skeep
                                                                 -)
                                                                (("2"
                                                                  (name
                                                                   "tt"
                                                                   "(s`x-p(i)`x)/(p(next)`x-p(i)`x)")
                                                                  (("2"
                                                                    (case
                                                                     "NOT t = tt")
                                                                    (("1"
                                                                      (case
                                                                       "NOT t*(p(next)`x-p(i)`x) = s`x - p(i)`x")
                                                                      (("1"
                                                                        (grind)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (expand
                                                                         "tt"
                                                                         1)
                                                                        (("2"
                                                                          (cross-mult
                                                                           1)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (replaces
                                                                       -1)
                                                                      (("2"
                                                                        (assert)
                                                                        (("2"
                                                                          (case
                                                                           "NOT (1 - tt) * p(i)`y + tt * p(next)`y - s`y>=0")
                                                                          (("1"
                                                                            (grind)
                                                                            nil
                                                                            nil)
                                                                           ("2"
                                                                            (hide-all-but
                                                                             (-1
                                                                              1
                                                                              2))
                                                                            (("2"
                                                                              (mult-by
                                                                               -1
                                                                               "sq(p(next)`x-p(i)`x)")
                                                                              (("2"
                                                                                (invoke
                                                                                 (case
                                                                                  "%1 = %2")
                                                                                 (!
                                                                                  -1
                                                                                  1)
                                                                                 (!
                                                                                  1
                                                                                  1))
                                                                                (("1"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil)
                                                                                 ("2"
                                                                                  (hide
                                                                                   (-1
                                                                                    2))
                                                                                  (("2"
                                                                                    (expand
                                                                                     "tt")
                                                                                    (("2"
                                                                                      (expand
                                                                                       "tester")
                                                                                      (("2"
                                                                                        (expand
                                                                                         "sq")
                                                                                        (("2"
                                                                                          (grind)
                                                                                          (("2"
                                                                                            (field)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide -1)
              (("2" (hide 2)
                (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (EdgeCross type-eq-decl nil acceptable_polygon nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (upshot_crosses_edge const-decl "EdgeCross" acceptable_polygon nil)
    (nnreal type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Vector type-eq-decl nil vectors_2D vectors)
    (+ const-decl "Vector" vectors_2D vectors)
    (* const-decl "Vector" vectors_2D vectors)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil) nil nil nil nil nil
    nil (both_sides_times_pos_ge1 formula-decl nil real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (both_sides_times1 formula-decl nil real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil) nil
    nil (sq const-decl "nonneg_real" sq reals)
    (expt def-decl "real" exponentiation nil)
    (div_cancel3 formula-decl nil real_props nil)
    (both_sides_minus_ge1 formula-decl nil real_props nil)
    (sq_gt_0 formula-decl nil sq reals)
    (div_mult_pos_neg_le1 formula-decl nil extra_real_props nil)
    (div_mult_pos_neg_le2 formula-decl nil extra_real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props
     nil)
    nil (- const-decl "[numfield -> numfield]" number_fields nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (div_cancel4 formula-decl nil real_props nil) nil
    (both_sides_times_pos_lt1 formula-decl nil real_props nil) nil
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (scal_0 formula-decl nil vectors_2D vectors)
    (scal_1 formula-decl nil vectors_2D vectors)
    (add_zero_left formula-decl nil vectors_2D vectors)
    (both_sides_times_pos_gt1 formula-decl nil real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil) nil
    (add_zero_right formula-decl nil vectors_2D vectors)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (compute_intercept_TCC1 0
  (compute_intercept_TCC1-1 nil 3634575881 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (/= const-decl "boolean" notequal nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (compute_intercept subtype "acceptable_polygon.newdenom" "nzreal")))
 (compute_intercept_def_TCC1 0
  (compute_intercept_def_TCC1-1 nil 3634575881
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (/= const-decl "boolean" notequal nil))
   nil
   (compute_intercept_def subtype
    "((number_fields.-)(acceptable_polygon.p(acceptable_polygon.next)`x, acceptable_polygon.p(acceptable_polygon.i)`x))"
    "nznum")))
 (compute_intercept_def 0
  (compute_intercept_def-1 nil 3634575935
   ("" (skeep)
    (("" (name "next" "IF i<N-1 THEN i+1 ELSE 0 ENDIF")
      (("" (replace -1)
        (("" (assert)
          (("" (name "ci" "compute_intercept(N,p,s,i)")
            (("" (replace -1)
              (("" (assert)
                (("" (invoke (case "NOT %1") (! 1 1))
                  (("1" (hide 2)
                    (("1"
                      (name "uce" "upshot_crosses_edge(N, p, s, i)")
                      (("1" (replace -1)
                        (("1"
                          (expand "upshot_crosses_edge" :assert? none)
                          (("1" (replace -3)
                            (("1"
                              (name "tester"
                                    "(p(next)`x - p(i)`x) ^ 2 * (p(i)`y - s`y) +
                                         (s`x - p(i)`x) * (p(next)`y - p(i)`y) * (p(next)`x - p(i)`x)")
                              (("1"
                                (label "td" -1)
                                (("1"
                                  (copy "td")
                                  (("1"
                                    (hide "td")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (replaces -1)
                                        (("1"
                                          (reveal "td")
                                          (("1"
                                            (copy "td")
                                            (("1"
                                              (hide "td")
                                              (("1"
                                                (lift-if -2)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (hide -1)
                                                    (("1"
                                                      (split -)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             "compute_intercept"
                                                             :assert?
                                                             none)
                                                            (("1"
                                                              (replace
                                                               -6)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (split -)
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (hide
                                                                 +)
                                                                (("1"
                                                                  (expand
                                                                   "compute_intercept"
                                                                   :assert?
                                                                   none)
                                                                  (("1"
                                                                    (replace
                                                                     -6)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (flatten)
                                                            (("2"
                                                              (split -)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (expand
                                                                     "compute_intercept"
                                                                     :assert?
                                                                     none)
                                                                    (("1"
                                                                      (replace
                                                                       -6)
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (split
                                                                   -)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (replace
                                                                         1)
                                                                        (("1"
                                                                          (assert)
                                                                          (("1"
                                                                            (expand
                                                                             "compute_intercept"
                                                                             :assert?
                                                                             none)
                                                                            (("1"
                                                                              (replace
                                                                               -5)
                                                                              (("1"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (hide
                                                                       2)
                                                                      (("2"
                                                                        (assert)
                                                                        (("2"
                                                                          (split
                                                                           -)
                                                                          (("1"
                                                                            (flatten)
                                                                            (("1"
                                                                              (assert)
                                                                              (("1"
                                                                                (expand
                                                                                 "compute_intercept"
                                                                                 :assert?
                                                                                 none)
                                                                                (("1"
                                                                                  (replace
                                                                                   -4)
                                                                                  (("1"
                                                                                    (case
                                                                                     "NOT (IF (p(i)`x > s`x AND p(next)`x > s`x) OR
                                                       (p(i)`x < s`x AND p(next)`x < s`x) OR p(i)`x = p(next)`x
                                                     THEN (# index := -1, num := 1, denom := 1 #)
                                                   ELSE LET newnum =
                                                              (p(i)`y - s`y) * (p(next)`x - p(i)`x) +
                                                               (s`x - p(i)`x) * (p(next)`y - p(i)`y),
                                                            newdenom = p(next)`x - p(i)`x
                                                          IN
                                                          IF newnum * newdenom < 0
                                                            THEN (# index := -1, num := 1, denom := 1 #)
                                                          ELSE (# index := i, num := newnum, denom := newdenom #)
                                                          ENDIF
                                                   ENDIF)
                                                 = ci")
                                                                                    (("1"
                                                                                      (assert)
                                                                                      nil
                                                                                      nil)
                                                                                     ("2"
                                                                                      (hide
                                                                                       -4)
                                                                                      (("2"
                                                                                        (lift-if
                                                                                         -1)
                                                                                        (("2"
                                                                                          (replace
                                                                                           2)
                                                                                          (("2"
                                                                                            (replace
                                                                                             3)
                                                                                            (("2"
                                                                                              (replace
                                                                                               1)
                                                                                              (("2"
                                                                                                (skoletin
                                                                                                 -)
                                                                                                (("2"
                                                                                                  (skoletin
                                                                                                   -)
                                                                                                  (("2"
                                                                                                    (lift-if)
                                                                                                    (("2"
                                                                                                      (split
                                                                                                       -)
                                                                                                      (("1"
                                                                                                        (flatten)
                                                                                                        (("1"
                                                                                                          (case
                                                                                                           "tester = newnum*newdenom")
                                                                                                          (("1"
                                                                                                            (assert)
                                                                                                            nil
                                                                                                            nil)
                                                                                                           ("2"
                                                                                                            (hide-all-but
                                                                                                             (1
                                                                                                              2))
                                                                                                            (("2"
                                                                                                              (expand
                                                                                                               "tester")
                                                                                                              (("2"
                                                                                                                (expand
                                                                                                                 "newnum")
                                                                                                                (("2"
                                                                                                                  (expand
                                                                                                                   "newdenom")
                                                                                                                  (("2"
                                                                                                                    (grind)
                                                                                                                    nil
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil)
                                                                                                       ("2"
                                                                                                        (flatten)
                                                                                                        (("2"
                                                                                                          (assert)
                                                                                                          nil
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (flatten)
                                                                            (("2"
                                                                              (assert)
                                                                              (("2"
                                                                                (expand
                                                                                 "compute_intercept"
                                                                                 :assert?
                                                                                 none)
                                                                                (("2"
                                                                                  (replace
                                                                                   -4)
                                                                                  (("2"
                                                                                    (case
                                                                                     "NOT (IF (p(i)`x > s`x AND p(next)`x > s`x) OR
                                                       (p(i)`x < s`x AND p(next)`x < s`x) OR p(i)`x = p(next)`x
                                                     THEN (# index := -1, num := 1, denom := 1 #)
                                                   ELSE LET newnum =
                                                              (p(i)`y - s`y) * (p(next)`x - p(i)`x) +
                                                               (s`x - p(i)`x) * (p(next)`y - p(i)`y),
                                                            newdenom = p(next)`x - p(i)`x
                                                          IN
                                                          IF newnum * newdenom < 0
                                                            THEN (# index := -1, num := 1, denom := 1 #)
                                                          ELSE (# index := i, num := newnum, denom := newdenom #)
                                                          ENDIF
                                                   ENDIF)
                                                 = ci")
                                                                                    (("1"
                                                                                      (assert)
                                                                                      nil
                                                                                      nil)
                                                                                     ("2"
                                                                                      (hide
                                                                                       -4)
                                                                                      (("2"
                                                                                        (lift-if
                                                                                         -)
                                                                                        (("2"
                                                                                          (replace
                                                                                           2)
                                                                                          (("2"
                                                                                            (replace
                                                                                             3)
                                                                                            (("2"
                                                                                              (replace
                                                                                               4)
                                                                                              (("2"
                                                                                                (skoletin
                                                                                                 -1)
                                                                                                (("2"
                                                                                                  (skoletin
                                                                                                   -1)
                                                                                                  (("2"
                                                                                                    (lift-if
                                                                                                     -1)
                                                                                                    (("2"
                                                                                                      (split
                                                                                                       -)
                                                                                                      (("1"
                                                                                                        (flatten)
                                                                                                        (("1"
                                                                                                          (assert)
                                                                                                          nil
                                                                                                          nil))
                                                                                                        nil)
                                                                                                       ("2"
                                                                                                        (flatten)
                                                                                                        (("2"
                                                                                                          (case
                                                                                                           "tester = newnum*newdenom")
                                                                                                          (("1"
                                                                                                            (assert)
                                                                                                            nil
                                                                                                            nil)
                                                                                                           ("2"
                                                                                                            (hide-all-but
                                                                                                             1)
                                                                                                            (("2"
                                                                                                              (expand
                                                                                                               "tester")
                                                                                                              (("2"
                                                                                                                (expand
                                                                                                                 "newnum")
                                                                                                                (("2"
                                                                                                                  (expand
                                                                                                                   "newdenom")
                                                                                                                  (("2"
                                                                                                                    (grind)
                                                                                                                    nil
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide (-1 2))
                                (("2"
                                  (lift-if)
                                  (("2" (ground) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (replace -1 :dir rl)
                    (("2" (assert)
                      (("2"
                        (name "uce" "upshot_crosses_edge(N, p, s, i)")
                        (("2" (replace -1)
                          (("2" (assert)
                            (("2" (flatten)
                              (("2"
                                (assert)
                                (("2"
                                  (hide -3)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (copy -3)
                                        (("2"
                                          (expand
                                           "compute_intercept"
                                           -1
                                           :assert?
                                           none)
                                          (("2"
                                            (replace -5)
                                            (("2"
                                              (case
                                               "NOT (IF (p(i)`x > s`x AND p(next)`x > s`x) OR
                      (p(i)`x < s`x AND p(next)`x < s`x) OR p(i)`x = p(next)`x
                    THEN (# index := -1, num := 1, denom := 1 #)
                  ELSE LET newnum =
                             (p(i)`y - s`y) * (p(next)`x - p(i)`x) +
                              (s`x - p(i)`x) * (p(next)`y - p(i)`y),
                           newdenom = p(next)`x - p(i)`x
                         IN
                         IF newnum * newdenom < 0
                           THEN (# index := -1, num := 1, denom := 1 #)
                         ELSE (# index := i, num := newnum, denom := newdenom #)
                         ENDIF
                  ENDIF)
                = ci")
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (hide -2)
                                                (("2"
                                                  (lift-if -1)
                                                  (("2"
                                                    (case
                                                     "NOT next <N")
                                                    (("1"
                                                      (hide (-1 3))
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (ground)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (split -)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (skoletin -1)
                                                          (("2"
                                                            (skoletin
                                                             -1)
                                                            (("2"
                                                              (lift-if
                                                               -)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (split
                                                                   -)
                                                                  (("1"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (split
                                                                       6)
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (hide (-1 3))
                                                (("3"
                                                  (flatten)
                                                  (("3"
                                                    (skeep*)
                                                    (("3"
                                                      (lift-if)
                                                      (("3"
                                                        (ground)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("4"
                                                (hide (-1 3))
                                                (("4"
                                                  (flatten)
                                                  (("4"
                                                    (lift-if)
                                                    (("4"
                                                      (ground)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("5"
                                                (flatten)
                                                (("5"
                                                  (hide (-1 5))
                                                  (("5"
                                                    (lift-if)
                                                    (("5"
                                                      (ground)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("6"
                                                (hide (-1 3))
                                                (("6"
                                                  (lift-if)
                                                  (("6"
                                                    (ground)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("7"
                                                (hide (-1 3))
                                                (("7"
                                                  (flatten)
                                                  (("7"
                                                    (lift-if)
                                                    (("7"
                                                      (ground)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((naturalnumber type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (upshot_crosses_edge const-decl "EdgeCross" acceptable_polygon nil)
    (EdgeCross type-eq-decl nil acceptable_polygon nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil) nil
    nil (expt def-decl "real" exponentiation nil) nil
    (- const-decl "[numfield -> numfield]" number_fields nil) nil nil
    (TRUE const-decl "bool" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (compute_intercept const-decl "CrossAns" acceptable_polygon nil)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (CrossAns type-eq-decl nil acceptable_polygon nil)
    (nzreal nonempty-type-eq-decl nil reals nil))
   shostak))
 (min_cross_dist_index_upto_TCC1 0
  (min_cross_dist_index_upto_TCC1-1 nil 3634580796
   ("" (skeep*)
    (("" (replace -1)
      (("" (assert)
        (("" (split)
          (("1" (flatten) (("1" (inst + "0") nil nil)) nil)
           ("2" (flatten)
            (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)
           ("3" (flatten)
            (("3" (name "ci" "compute_intercept(N, p, s, 0)")
              (("3" (replace -1)
                (("3" (assert)
                  (("3" (case "NOT ci`index < N")
                    (("1" (hide 2)
                      (("1" (hide -1)
                        (("1" (hide -1)
                          (("1" (expand "ci")
                            (("1" (expand "compute_intercept")
                              (("1"
                                (lift-if)
                                (("1"
                                  (assert)
                                  (("1"
                                    (lift-if)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert) (("2" (postpone) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_cross_dist_index_upto subtype "acceptable_polygon.j"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (min_cross_dist_index_upto_TCC2 0
  (min_cross_dist_index_upto_TCC2-2 nil 3634582053
   ("" (skeep*)
    (("" (replace -1)
      (("" (assert)
        (("" (split)
          (("1" (flatten) (("1" (inst + "0") nil nil)) nil)
           ("2" (flatten)
            (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)
           ("3" (flatten)
            (("3" (name "ci" "compute_intercept(N, p, s, 0)")
              (("3" (replace -1)
                (("3" (assert)
                  (("3" (case "NOT ci`index <= i")
                    (("1" (hide 2)
                      (("1" (hide -1)
                        (("1" (hide -1)
                          (("1" (expand "ci")
                            (("1" (expand "compute_intercept")
                              (("1"
                                (lift-if)
                                (("1"
                                  (assert)
                                  (("1"
                                    (lift-if)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_cross_dist_index_upto subtype "acceptable_polygon.ca`index"
    "naturalnumbers.below(acceptable_polygon.N)"))
  (min_cross_dist_index_upto_TCC2-1 nil 3634580796
   ("" (subtype-tcc) nil nil) nil nil
   (min_cross_dist_index_upto subtype "acceptable_polygon.ca`index"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (min_cross_dist_index_upto_TCC3 0
  (min_cross_dist_index_upto_TCC3-2 nil 3651833734
   ("" (skeep*)
    (("" (replace -1)
      (("" (assert)
        (("" (split)
          (("1" (flatten) (("1" (inst + "0") nil nil)) nil)
           ("2" (flatten)
            (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)
           ("3" (flatten)
            (("3" (name "ci" "compute_intercept(N, p, s, 0)")
              (("3" (replace -1)
                (("3" (assert)
                  (("3" (case "NOT ci`index <= i")
                    (("1" (hide 2)
                      (("1" (hide -1)
                        (("1" (hide -1)
                          (("1" (expand "ci")
                            (("1" (expand "compute_intercept")
                              (("1"
                                (lift-if)
                                (("1"
                                  (assert)
                                  (("1"
                                    (lift-if)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (compute_intercept const-decl "CrossAns" acceptable_polygon nil)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (CrossAns type-eq-decl nil acceptable_polygon nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_cross_dist_index_upto subtype
    "acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, acceptable_polygon.i)"
    "{ca: acceptable_polygon.CrossAns | booleans.AND((booleans.IFF(reals.>=(ca`index, 0), EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0))), (booleans.IMPLIES(reals.>=(ca`index, 0), (booleans.AND(reals.<=(ca`index, acceptable_polygon.i), booleans.AND(ca = acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, ca`index), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0), reals.>=(number_fields./(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`num, acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`denom), number_fields./(ca`num, ca`denom)))))))))}"))
  (min_cross_dist_index_upto_TCC3-1 nil 3634580796
   ("" (termination-tcc) nil nil) nil nil
   (min_cross_dist_index_upto subtype
    "acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, acceptable_polygon.i)"
    "{ca: acceptable_polygon.CrossAns | booleans.AND((booleans.IFF(reals.>=(ca`index, 0), EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0))), (booleans.IMPLIES(reals.>=(ca`index, 0), (booleans.AND(reals.<=(ca`index, acceptable_polygon.i), booleans.AND(ca = acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, ca`index), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0), reals.>=(number_fields./(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`num, acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`denom), number_fields./(ca`num, ca`denom)))))))))}")))
 (min_cross_dist_index_upto_TCC4 0
  (min_cross_dist_index_upto_TCC4-1 nil 3634580796
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (min_cross_dist_index_upto subtype
    "(number_fields.-)(acceptable_polygon.i, 1)"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (min_cross_dist_index_upto_TCC5 0
  (min_cross_dist_index_upto_TCC5-1 nil 3634580796
   ("" (skeep*)
    (("" (assert)
      (("" (split +)
        (("1" (flatten)
          (("1" (inst + "i") (("1" (assert) nil nil)) nil)) nil)
         ("2" (flatten)
          (("2" (skeep)
            (("2" (case "j/=i")
              (("1" (flatten)
                (("1" (typepred "v(N,p,s,i-1)")
                  (("1" (hide (-1 -3))
                    (("1" (assert) (("1" (inst + "j") nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil)
         ("3" (flatten)
          (("3" (case "NOT cii`index = i")
            (("1" (assert)
              (("1" (hide 2)
                (("1" (expand "compute_intercept" :assert? none)
                  (("1"
                    (name "next"
                          "(IF i < N - 1 THEN i + 1 ELSE 0 ENDIF)")
                    (("1" (replace -1)
                      (("1" (assert)
                        (("1" (hide -1)
                          (("1" (lift-if) (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (skeep)
                (("2" (typepred "j")
                  (("2" (case "j = i")
                    (("1" (assert) nil nil)
                     ("2" (typepred "v(N,p,s,i-1)")
                      (("2" (assert) (("2" (inst + "j") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_cross_dist_index_upto termination
    "acceptable_polygon.min_cross_dist_index_upto(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, (number_fields.-)(acceptable_polygon.i, 1))"
    "nil")))
 (min_cross_dist_index_upto_TCC6 0
  (min_cross_dist_index_upto_TCC6-2 nil 3651833340
   ("" (skeep*)
    (("" (assert)
      (("" (split +)
        (("1" (flatten)
          (("1" (inst + "i") (("1" (assert) nil nil)) nil)) nil)
         ("2" (flatten)
          (("2" (skeep)
            (("2" (case "j/=i")
              (("1" (flatten)
                (("1" (typepred "v(N,p,s,i-1)")
                  (("1" (hide (-1 -3))
                    (("1" (assert) (("1" (inst + "j") nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil)
         ("3" (flatten)
          (("3" (case "NOT cii`index = i")
            (("1" (assert)
              (("1" (hide 2)
                (("1" (expand "compute_intercept" :assert? none)
                  (("1"
                    (name "next"
                          "(IF i < N - 1 THEN i + 1 ELSE 0 ENDIF)")
                    (("1" (replace -1)
                      (("1" (assert)
                        (("1" (hide -1)
                          (("1" (lift-if) (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (skeep)
                (("2" (typepred "j")
                  (("2" (case "j = i")
                    (("1" (assert) nil nil)
                     ("2" (typepred "v(N,p,s,i-1)")
                      (("2" (assert) (("2" (inst + "j") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (compute_intercept const-decl "CrossAns" acceptable_polygon nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (CrossAns type-eq-decl nil acceptable_polygon nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_cross_dist_index_upto subtype "acceptable_polygon.cii"
    "{ca: acceptable_polygon.CrossAns | booleans.AND((booleans.IFF(reals.>=(ca`index, 0), EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0))), (booleans.IMPLIES(reals.>=(ca`index, 0), (booleans.AND(reals.<=(ca`index, acceptable_polygon.i), booleans.AND(ca = acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, ca`index), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0), reals.>=(number_fields./(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`num, acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`denom), number_fields./(ca`num, ca`denom)))))))))}"))
  (min_cross_dist_index_upto_TCC6-1 nil 3634580796
   ("" (skeep*)
    (("" (assert)
      (("" (typepred "v(N,p,s,i-1)")
        (("" (assert)
          (("" (hide -2)
            (("" (split +)
              (("1" (skeep) (("1" (inst + "j") nil nil)) nil)
               ("2" (flatten) (("2" (assert) nil nil)) nil)
               ("3" (assert) nil nil)
               ("4" (assert)
                (("4" (flatten)
                  (("4" (skeep)
                    (("4" (typepred "j")
                      (("4" (inst - "j")
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Vect2 type-eq-decl nil vectors_2D_def vectors)) nil
   (min_cross_dist_index_upto subtype "acceptable_polygon.cii"
    "{ca: acceptable_polygon.CrossAns | booleans.AND((booleans.IFF(reals.>=(ca`index, 0), EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0))), (booleans.IMPLIES(reals.>=(ca`index, 0), (booleans.AND(reals.<=(ca`index, acceptable_polygon.i), booleans.AND(ca = acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, ca`index), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0), reals.>=(number_fields./(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`num, acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`denom), number_fields./(ca`num, ca`denom)))))))))}")))
 (min_cross_dist_index_upto_TCC7 0
  (min_cross_dist_index_upto_TCC7-2 nil 3651833320
   ("" (skeep*)
    (("" (assert)
      (("" (typepred "v(N,p,s,i-1)")
        (("" (assert)
          (("" (hide -2)
            (("" (split +)
              (("1" (skeep) (("1" (inst + "j") nil nil)) nil)
               ("2" (flatten) (("2" (assert) nil nil)) nil)
               ("3" (assert) nil nil)
               ("4" (assert)
                (("4" (flatten)
                  (("4" (skeep)
                    (("4" (typepred "j")
                      (("4" (inst - "j")
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    nil nil nil (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (CrossAns type-eq-decl nil acceptable_polygon nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (compute_intercept const-decl "CrossAns" acceptable_polygon nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_cross_dist_index_upto subtype "acceptable_polygon.cin"
    "{ca: acceptable_polygon.CrossAns | booleans.AND((booleans.IFF(reals.>=(ca`index, 0), EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0))), (booleans.IMPLIES(reals.>=(ca`index, 0), (booleans.AND(reals.<=(ca`index, acceptable_polygon.i), booleans.AND(ca = acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, ca`index), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0), reals.>=(number_fields./(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`num, acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`denom), number_fields./(ca`num, ca`denom)))))))))}"))
  (min_cross_dist_index_upto_TCC7-1 nil 3634580796
   ("" (subtype-tcc) nil nil) nil nil
   (min_cross_dist_index_upto subtype "acceptable_polygon.cin"
    "{ca: acceptable_polygon.CrossAns | booleans.AND((booleans.IFF(reals.>=(ca`index, 0), EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0))), (booleans.IMPLIES(reals.>=(ca`index, 0), (booleans.AND(reals.<=(ca`index, acceptable_polygon.i), booleans.AND(ca = acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, ca`index), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0), reals.>=(number_fields./(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`num, acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`denom), number_fields./(ca`num, ca`denom)))))))))}")))
 (min_cross_dist_index_upto_TCC8 0
  (min_cross_dist_index_upto_TCC8-1 nil 3634580796
   ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil))
   nil
   (min_cross_dist_index_upto subtype "2"
    "{i: integers.int | booleans.OR(acceptable_polygon.cin`denom /= 0, reals.>=(i, 0))}")))
 (min_cross_dist_index_upto_TCC9 0
  (min_cross_dist_index_upto_TCC9-1 nil 3634580796
   ("" (skeep*)
    (("" (assert)
      (("" (case "NOT cii`index = i")
        (("1" (hide 5)
          (("1" (expand "compute_intercept" :assert? none)
            (("1"
              (name "next" "(IF i < N - 1 THEN i + 1 ELSE 0 ENDIF)")
              (("1" (replaces -1)
                (("1" (assert)
                  (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (split)
            (("1" (inst + "i") (("1" (assert) nil nil)) nil)
             ("2" (skeep)
              (("2" (replace -2)
                (("2" (case "j = i")
                  (("1" (assert) nil nil)
                   ("2" (case "cin`num/cin`denom>=cii`num/cii`denom")
                    (("1" (typepred "v(N,p,s,i-1)")
                      (("1" (replace -9 :dir rl)
                        (("1" (assert)
                          (("1" (hide -2)
                            (("1" (flatten)
                              (("1"
                                (inst - "j")
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (mult-by 1 "sq(cin`denom)*sq(cii`denom)")
                      (("2" (hide-all-but (-4 1))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_cross_dist_index_upto subtype "2"
    "{i: integers.int | booleans.OR(acceptable_polygon.cii`denom /= 0, reals.>=(i, 0))}")))
 (min_cross_dist_index_upto_TCC10 0
  (min_cross_dist_index_upto_TCC10-2 nil 3651833295
   ("" (skeep*)
    (("" (assert)
      (("" (case "NOT cii`index = i")
        (("1" (hide 5)
          (("1" (expand "compute_intercept" :assert? none)
            (("1"
              (name "next" "(IF i < N - 1 THEN i + 1 ELSE 0 ENDIF)")
              (("1" (replaces -1)
                (("1" (assert)
                  (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (split)
            (("1" (inst + "i") (("1" (assert) nil nil)) nil)
             ("2" (skeep)
              (("2" (replace -2)
                (("2" (case "j = i")
                  (("1" (assert) nil nil)
                   ("2" (case "cin`num/cin`denom>=cii`num/cii`denom")
                    (("1" (typepred "v(N,p,s,i-1)")
                      (("1" (replace -8 :dir rl)
                        (("1" (assert)
                          (("1" (hide -2)
                            (("1" (flatten)
                              (("1"
                                (inst - "j")
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (mult-by 1 "sq(cin`denom)*sq(cii`denom)")
                      (("2" (hide-all-but (-5 1))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (both_sides_times_pos_ge1 formula-decl nil real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sq const-decl "nonneg_real" sq reals)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (nzreal_expt application-judgement "nzreal" exponentiation nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (sq_nz_pos application-judgement "posreal" sq reals)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (compute_intercept const-decl "CrossAns" acceptable_polygon nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (real nonempty-type-from-decl nil reals nil)
    (CrossAns type-eq-decl nil acceptable_polygon nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_cross_dist_index_upto subtype "acceptable_polygon.cii"
    "{ca: acceptable_polygon.CrossAns | booleans.AND((booleans.IFF(reals.>=(ca`index, 0), EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0))), (booleans.IMPLIES(reals.>=(ca`index, 0), (booleans.AND(reals.<=(ca`index, acceptable_polygon.i), booleans.AND(ca = acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, ca`index), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0), reals.>=(number_fields./(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`num, acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`denom), number_fields./(ca`num, ca`denom)))))))))}"))
  (min_cross_dist_index_upto_TCC10-1 nil 3634581969
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (split)
          (("1" (inst + "i") (("1" (assert) nil nil)) nil)
           ("2" (assert)
            (("2" (typepred "cin") (("2" (assert) nil nil)) nil)) nil)
           ("3" (typepred "cin") (("3" (assert) nil nil)) nil)
           ("4" (typepred "cin")
            (("4" (skeep)
              (("4" (case "NOT j = i")
                (("1" (assert)
                  (("1" (flatten)
                    (("1" (inst - "j") (("1" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (replace -1)
                  (("2" (assert)
                    (("2" (replace -6 :dir rl)
                      (("2" (hide -)
                        (("2" (mult-by 1 "sq(cin`denom)*sq(cii`denom)")
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Vect2 type-eq-decl nil vectors_2D_def vectors)
    (sq const-decl "nonneg_real" sq reals)
    (sq_nz_pos application-judgement "posreal" sq reals))
   nil
   (min_cross_dist_index_upto subtype "acceptable_polygon.cii"
    "{ca: acceptable_polygon.CrossAns | booleans.AND((booleans.IFF(reals.>=(ca`index, 0), EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0))), (booleans.IMPLIES(reals.>=(ca`index, 0), (booleans.AND(reals.<=(ca`index, acceptable_polygon.i), booleans.AND(ca = acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, ca`index), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0), reals.>=(number_fields./(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`num, acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`denom), number_fields./(ca`num, ca`denom)))))))))}")))
 (min_cross_dist_index_upto_TCC11 0
  (min_cross_dist_index_upto_TCC11-2 nil 3651833273
   ("" (skeep*)
    (("" (assert)
      (("" (assert)
        (("" (split)
          (("1" (inst + "i") (("1" (assert) nil nil)) nil)
           ("2" (assert)
            (("2" (typepred "cin") (("2" (assert) nil nil)) nil)) nil)
           ("3" (typepred "cin") (("3" (assert) nil nil)) nil)
           ("4" (typepred "cin")
            (("4" (skeep)
              (("4" (case "NOT j = i")
                (("1" (assert)
                  (("1" (flatten)
                    (("1" (inst - "j") (("1" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (replace -1)
                  (("2" (assert)
                    (("2" (replace -6 :dir rl)
                      (("2" (hide -)
                        (("2" (mult-by 1 "sq(cin`denom)*sq(cii`denom)")
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (compute_intercept const-decl "CrossAns" acceptable_polygon nil)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (CrossAns type-eq-decl nil acceptable_polygon nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (both_sides_times_pos_ge1 formula-decl nil real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sq const-decl "nonneg_real" sq reals)
    (sq_nz_pos application-judgement "posreal" sq reals)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (nzreal_expt application-judgement "nzreal" exponentiation nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_cross_dist_index_upto subtype "acceptable_polygon.cin"
    "{ca: acceptable_polygon.CrossAns | booleans.AND((booleans.IFF(reals.>=(ca`index, 0), EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0))), (booleans.IMPLIES(reals.>=(ca`index, 0), (booleans.AND(reals.<=(ca`index, acceptable_polygon.i), booleans.AND(ca = acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, ca`index), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0), reals.>=(number_fields./(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`num, acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`denom), number_fields./(ca`num, ca`denom)))))))))}"))
  (min_cross_dist_index_upto_TCC11-1 nil 3651832370
   ("" (subtype-tcc) nil nil) nil nil
   (min_cross_dist_index_upto subtype "acceptable_polygon.cin"
    "{ca: acceptable_polygon.CrossAns | booleans.AND((booleans.IFF(reals.>=(ca`index, 0), EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0))), (booleans.IMPLIES(reals.>=(ca`index, 0), (booleans.AND(reals.<=(ca`index, acceptable_polygon.i), booleans.AND(ca = acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, ca`index), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.>=(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`index, 0), reals.>=(number_fields./(acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`num, acceptable_polygon.compute_intercept(acceptable_polygon.N, acceptable_polygon.p, acceptable_polygon.s, j)`denom), number_fields./(ca`num, ca`denom)))))))))}")))
 (acceptable_polygon_2D_TCC1 0
  (acceptable_polygon_2D_TCC1-1 nil 3640969777
   ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mod const-decl "{k | abs(k) < abs(j)}" mod nil))
   nil
   (acceptable_polygon_2D subtype "acceptable_polygon.j"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (acceptable_polygon_2D_TCC2 0
  (acceptable_polygon_2D_TCC2-1 nil 3640969777
   ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mod const-decl "{k | abs(k) < abs(j)}" mod nil))
   nil
   (acceptable_polygon_2D subtype "acceptable_polygon.i"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (acceptable_polygon_2D_TCC3 0
  (acceptable_polygon_2D_TCC3-1 nil 3640969777
   ("" (skeep*)
    (("" (lemma "mod_lt") (("" (inst?) (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((mod_lt formula-decl nil mod nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nzint_abs_is_pos application-judgement "{j: posint | j >= i}"
     real_defs nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil application-judgement "below(m)" mod nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonzero_integer nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (subrange type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (acceptable_polygon_2D subtype "acceptable_polygon.mi"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (acceptable_polygon_2D_TCC4 0
  (acceptable_polygon_2D_TCC4-1 nil 3640969777
   ("" (skeep*)
    (("" (lemma "mod_lt") (("" (inst?) (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((mod_lt formula-decl nil mod nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nzint_abs_is_pos application-judgement "{j: posint | j >= i}"
     real_defs nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil application-judgement "below(m)" mod nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonzero_integer nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (subrange type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (acceptable_polygon_2D subtype "acceptable_polygon.mj"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (polygon_indices_distinct 0
  (polygon_indices_distinct-1 nil 3641024800
   (""
    (case "FORALL (N: posnat, i, j: nat):
        i = mod(j + 1, N) AND j = mod(i + 1, N) AND i<=j IMPLIES N < 3")
    (("1" (skeep)
      (("1" (inst-cp - "N" "i" "j")
        (("1" (inst - "N" "j" "i") (("1" (ground) nil nil)) nil)) nil))
      nil)
     ("2" (hide 2)
      (("2" (skeep)
        (("2" (case "i = j")
          (("1" (hide -4)
            (("1" (replaces -1 :dir rl)
              (("1" (hide -2)
                (("1" (case "NOT i<N")
                  (("1" (assert) nil nil)
                   ("2" (expand "mod")
                    (("2" (case "i+1<N")
                      (("1" (case "floor((1+i)/N)=0")
                        (("1" (assert) nil nil)
                         ("2" (case "0<=(1+i)/N AND (1+i)/N<1")
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (split 1)
                            (("1" (cross-mult 1) nil nil)
                             ("2" (cross-mult 1)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (case "NOT i = N-1")
                        (("1" (assert) nil nil)
                         ("2" (replace -1)
                          (("2" (assert)
                            (("2" (lemma "floor_int")
                              (("2"
                                (inst - "1")
                                (("2"
                                  (replaces -1)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (case "NOT i<j")
            (("1" (assert) nil nil)
             ("2" (hide (-4 1))
              (("2" (case "j+1<N")
                (("1" (case "floor((j+1)/N)=0")
                  (("1" (expand "mod" -4)
                    (("1" (replaces -1) (("1" (assert) nil nil)) nil))
                    nil)
                   ("2" (case "(j+1)/N<1")
                    (("1" (assert) nil nil)
                     ("2" (cross-mult 1) (("2" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (case "NOT j = N-1")
                  (("1" (assert) nil nil)
                   ("2" (replace -1)
                    (("2" (assert)
                      (("2" (expand "mod" -3)
                        (("2" (lemma "floor_int")
                          (("2" (inst - "1")
                            (("2" (replaces -1)
                              (("2"
                                (assert)
                                (("2"
                                  (replace -3)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand "mod")
                                      (("2"
                                        (case "floor(1/N)=0")
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (case "1/N <1")
                                          (("1" (assert) nil nil)
                                           ("2"
                                            (cross-mult 1)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (div_mult_pos_lt1 formula-decl nil real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (div_mult_pos_le2 formula-decl nil real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (integer nonempty-type-from-decl nil integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (floor_int formula-decl nil floor_ceil nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "below(m)" mod nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (/= const-decl "boolean" notequal nil)
    (nonzero_integer nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (mod const-decl "{k | abs(k) < abs(j)}" mod nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil))
   shostak))
 (acceptable_polygon_2D_def_TCC1 0
  (acceptable_polygon_2D_def_TCC1-1 nil 3641024381
   ("" (subtype-tcc) nil nil)
   ((mod const-decl "{k | abs(k) < abs(j)}" mod nil)
    (near_poly_edge const-decl "bool" acceptable_polygon nil) nil
    (* const-decl "real" vectors_2D vectors)
    (sqv const-decl "nnreal" vectors_2D vectors)
    (norm const-decl "nnreal" vectors_2D vectors)
    (acceptable_polygon_2D const-decl "bool" acceptable_polygon nil)
    (/= const-decl "boolean" notequal nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (acceptable_polygon_2D_def subtype "acceptable_polygon.i"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (acceptable_polygon_2D_def_TCC2 0
  (acceptable_polygon_2D_def_TCC2-1 nil 3641024381
   ("" (subtype-tcc) nil nil)
   ((mod const-decl "{k | abs(k) < abs(j)}" mod nil)
    (near_poly_edge const-decl "bool" acceptable_polygon nil) nil
    (* const-decl "real" vectors_2D vectors)
    (sqv const-decl "nnreal" vectors_2D vectors)
    (norm const-decl "nnreal" vectors_2D vectors)
    (acceptable_polygon_2D const-decl "bool" acceptable_polygon nil)
    (/= const-decl "boolean" notequal nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (acceptable_polygon_2D_def subtype "acceptable_polygon.j"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (acceptable_polygon_2D_def 0
  (acceptable_polygon_2D_def-1 nil 3641024446
   ("" (skeep*)
    (("" (expand "acceptable_polygon_2D")
      (("" (flatten)
        (("" (case "i<=j")
          (("1" (insteep -)
            (("1" (insteep -)
              (("1" (assert)
                (("1" (split -)
                  (("1" (propax) nil nil)
                   ("2" (flatten)
                    (("2" (split -)
                      (("1" (propax) nil nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (split -)
                            (("1" (propax) nil nil)
                             ("2" (flatten)
                              (("2"
                                (split -)
                                (("1"
                                  (lemma "polygon_indices_distinct")
                                  (("1"
                                    (insteep -)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (split -)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split -)
                                          (("1" (propax) nil nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split -)
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (split -)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (inst - "j")
            (("2" (inst - "i")
              (("1" (assert)
                (("1" (split -)
                  (("1" (propax) nil nil)
                   ("2" (flatten)
                    (("2" (split -)
                      (("1" (propax) nil nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (split -)
                            (("1" (propax) nil nil)
                             ("2" (flatten)
                              (("2"
                                (split -)
                                (("1"
                                  (lemma "polygon_indices_distinct")
                                  (("1"
                                    (insteep -)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (split -)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split -)
                                          (("1" (propax) nil nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split -)
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (split -)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      (("2"
                                                        (lemma
                                                         "segments_2D_close_def")
                                                        (("2"
                                                          (rewrite
                                                           -1
                                                           -3
                                                           :dir
                                                           rl)
                                                          (("2"
                                                            (rewrite
                                                             -1
                                                             :dir
                                                             rl)
                                                            (("2"
                                                              (hide -1)
                                                              (("2"
                                                                (skeep*)
                                                                (("2"
                                                                  (inst
                                                                   +
                                                                   "v"
                                                                   "w")
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (hide-all-but
                                                                       (-4
                                                                        1))
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "below(m)" mod nil)
    (acceptable_polygon_2D const-decl "bool" acceptable_polygon nil)
    (subrange type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil) nil nil nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (polygon_indices_distinct formula-decl nil acceptable_polygon nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (/= const-decl "boolean" notequal nil)
    (nonzero_integer nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (mod const-decl "{k | abs(k) < abs(j)}" mod nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sq const-decl "nonneg_real" sq reals)
    (sqv const-decl "nnreal" vectors_2D vectors)
    (* const-decl "real" vectors_2D vectors) nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sq_nz_pos application-judgement "posreal" sq reals)
    (segments_2D_close_def formula-decl nil edge_proximity nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (counterclockwise_corner_index_TCC1 0
  (counterclockwise_corner_index_TCC1-1 nil 3652541071
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign reals)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (counterclockwise_corner_index subtype "acceptable_polygon.i"
    "{j: naturalnumbers.nat | booleans.AND(reals.<(j, acceptable_polygon.N), FORALL (z: naturalnumbers.below(acceptable_polygon.N)): booleans.IMPLIES(reals.<=(z, acceptable_polygon.i), (booleans.AND(reals.>=(number_fields.*(acceptable_polygon.eps, acceptable_polygon.p(z)`x), number_fields.*(acceptable_polygon.eps, acceptable_polygon.p(j)`x)), (booleans.IMPLIES(acceptable_polygon.p(z)`x = acceptable_polygon.p(j)`x, reals.>=(acceptable_polygon.p(z)`y, acceptable_polygon.p(j)`y)))))))}")))
 (counterclockwise_corner_index_TCC2 0
  (counterclockwise_corner_index_TCC2-1 nil 3652541071
   ("" (subtype-tcc) nil nil) nil nil
   (counterclockwise_corner_index subtype
    "(number_fields.-)(acceptable_polygon.N, 1)" "nat")))
 (counterclockwise_corner_index_TCC3 0
  (counterclockwise_corner_index_TCC3-1 nil 3652541071
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign reals)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (counterclockwise_corner_index termination
    "acceptable_polygon.counterclockwise_corner_index(acceptable_polygon.N, acceptable_polygon.p, (number_fields.-)(acceptable_polygon.N, 1), acceptable_polygon.eps)"
    "nil")))
 (counterclockwise_corner_index_TCC4 0
  (counterclockwise_corner_index_TCC4-1 nil 3652541071
   ("" (skeep*)
    (("" (typepred "v(N,p,N-1,eps)")
      (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
    nil)
   ((- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Sign type-eq-decl nil sign reals)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (below type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (counterclockwise_corner_index subtype
    "acceptable_polygon.counterclockwise_corner_index(acceptable_polygon.N, acceptable_polygon.p, (number_fields.-)(acceptable_polygon.N, 1), acceptable_polygon.eps)"
    "{j: naturalnumbers.nat | booleans.AND(reals.<(j, acceptable_polygon.N), FORALL (z: naturalnumbers.below(acceptable_polygon.N)): booleans.IMPLIES(reals.<=(z, acceptable_polygon.i), (booleans.AND(reals.>=(number_fields.*(acceptable_polygon.eps, acceptable_polygon.p(z)`x), number_fields.*(acceptable_polygon.eps, acceptable_polygon.p(j)`x)), (booleans.IMPLIES(acceptable_polygon.p(z)`x = acceptable_polygon.p(j)`x, reals.>=(acceptable_polygon.p(z)`y, acceptable_polygon.p(j)`y)))))))}")))
 (counterclockwise_corner_index_TCC5 0
  (counterclockwise_corner_index_TCC5-1 nil 3652541071
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (counterclockwise_corner_index subtype "acceptable_polygon.windex"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (counterclockwise_corner_index_TCC6 0
  (counterclockwise_corner_index_TCC6-1 nil 3652541071
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (counterclockwise_corner_index subtype "acceptable_polygon.i"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (counterclockwise_corner_index_TCC7 0
  (counterclockwise_corner_index_TCC7-1 nil 3652541071
   ("" (skeep*)
    (("" (assert)
      (("" (skeep*)
        (("" (typepred "v(N,p,i-1,eps)")
          (("" (assert)
            (("" (case "z = i")
              (("1" (assert) nil nil)
               ("2" (inst - "z") (("2" (ground) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Sign type-eq-decl nil sign reals)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (below type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (counterclockwise_corner_index subtype "acceptable_polygon.i"
    "{j: naturalnumbers.nat | booleans.AND(reals.<(j, acceptable_polygon.N), FORALL (z: naturalnumbers.below(acceptable_polygon.N)): booleans.IMPLIES(reals.<=(z, acceptable_polygon.i), (booleans.AND(reals.>=(number_fields.*(acceptable_polygon.eps, acceptable_polygon.p(z)`x), number_fields.*(acceptable_polygon.eps, acceptable_polygon.p(j)`x)), (booleans.IMPLIES(acceptable_polygon.p(z)`x = acceptable_polygon.p(j)`x, reals.>=(acceptable_polygon.p(z)`y, acceptable_polygon.p(j)`y)))))))}")))
 (counterclockwise_corner_index_TCC8 0
  (counterclockwise_corner_index_TCC8-1 nil 3652541071
   ("" (skeep*)
    (("" (assert)
      (("" (typepred "v(N,p,i-1,eps)")
        (("" (skeep*) (("" (inst - "z") (("" (ground) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign reals)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (counterclockwise_corner_index subtype "acceptable_polygon.windex"
    "{j: naturalnumbers.nat | booleans.AND(reals.<(j, acceptable_polygon.N), FORALL (z: naturalnumbers.below(acceptable_polygon.N)): booleans.IMPLIES(reals.<=(z, acceptable_polygon.i), (booleans.AND(reals.>=(number_fields.*(acceptable_polygon.eps, acceptable_polygon.p(z)`x), number_fields.*(acceptable_polygon.eps, acceptable_polygon.p(j)`x)), (booleans.IMPLIES(acceptable_polygon.p(z)`x = acceptable_polygon.p(j)`x, reals.>=(acceptable_polygon.p(z)`y, acceptable_polygon.p(j)`y)))))))}")))
 (counterclockwise_corner_index_TCC9 0
  (counterclockwise_corner_index_TCC9-1 nil 3652541071
   ("" (skeep*)
    (("" (assert)
      (("" (skeep*)
        (("" (typepred "v(N,p,i-1,eps)")
          (("" (inst - "z") (("" (ground) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Sign type-eq-decl nil sign reals)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (below type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (counterclockwise_corner_index subtype "acceptable_polygon.i"
    "{j: naturalnumbers.nat | booleans.AND(reals.<(j, acceptable_polygon.N), FORALL (z: naturalnumbers.below(acceptable_polygon.N)): booleans.IMPLIES(reals.<=(z, acceptable_polygon.i), (booleans.AND(reals.>=(number_fields.*(acceptable_polygon.eps, acceptable_polygon.p(z)`x), number_fields.*(acceptable_polygon.eps, acceptable_polygon.p(j)`x)), (booleans.IMPLIES(acceptable_polygon.p(z)`x = acceptable_polygon.p(j)`x, reals.>=(acceptable_polygon.p(z)`y, acceptable_polygon.p(j)`y)))))))}")))
 (counterclockwise_corner_index_TCC10 0
  (counterclockwise_corner_index_TCC10-1 nil 3652541071
   ("" (skeep*)
    (("" (assert)
      (("" (typepred "v(N,p,i-1,eps)")
        (("" (skeep) (("" (inst - "z") (("" (ground) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign reals)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (counterclockwise_corner_index subtype "acceptable_polygon.windex"
    "{j: naturalnumbers.nat | booleans.AND(reals.<(j, acceptable_polygon.N), FORALL (z: naturalnumbers.below(acceptable_polygon.N)): booleans.IMPLIES(reals.<=(z, acceptable_polygon.i), (booleans.AND(reals.>=(number_fields.*(acceptable_polygon.eps, acceptable_polygon.p(z)`x), number_fields.*(acceptable_polygon.eps, acceptable_polygon.p(j)`x)), (booleans.IMPLIES(acceptable_polygon.p(z)`x = acceptable_polygon.p(j)`x, reals.>=(acceptable_polygon.p(z)`y, acceptable_polygon.p(j)`y)))))))}")))
 (counterclockwise_corner_index_TCC11 0
  (counterclockwise_corner_index_TCC11-1 nil 3652541071
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign reals)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (counterclockwise_corner_index subtype
    "(number_fields.-)(acceptable_polygon.i, 1)" "nat")))
 (counterclockwise_corner_index_TCC12 0
  (counterclockwise_corner_index_TCC12-1 nil 3652541071
   ("" (termination-tcc) nil nil) nil nil
   (counterclockwise_corner_index termination
    "acceptable_polygon.counterclockwise_corner_index(acceptable_polygon.N, acceptable_polygon.p, (number_fields.-)(acceptable_polygon.i, 1), acceptable_polygon.eps)"
    "nil")))
 (counterclockwise_corner_index_def 0
  (counterclockwise_corner_index_def-1 nil 3687797692
   ("" (skeep*) (("" (skoletin) (("" (assert) nil nil)) nil)) nil)
   ((IFF const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Sign type-eq-decl nil sign reals)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (counterclockwise_corner_index def-decl "{j: nat |
   j < N AND
    FORALL (z: below(N)):
      z <= i IMPLIES
       (eps * p(z)`x >= eps * p(j)`x AND
         (p(z)`x = p(j)`x IMPLIES p(z)`y >= p(j)`y))}"
     acceptable_polygon nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (min_y_val_TCC1 0
  (min_y_val_TCC1-1 nil 3652545389 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (min_y_val subtype "acceptable_polygon.i"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (min_y_val_TCC2 0
  (min_y_val_TCC2-1 nil 3652545389 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (min_y_val subtype "acceptable_polygon.p(acceptable_polygon.i)`y"
    "{r: reals.real | booleans.AND(EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.AND(reals.<(j, acceptable_polygon.N), r = acceptable_polygon.p(j)`y), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.<(j, acceptable_polygon.N), reals.>=(acceptable_polygon.p(j)`y, r)))}")))
 (min_y_val_TCC3 0
  (min_y_val_TCC3-1 nil 3652545389 ("" (subtype-tcc) nil nil) nil nil
   (min_y_val subtype "(number_fields.-)(acceptable_polygon.N, 1)"
    "nat")))
 (min_y_val_TCC4 0
  (min_y_val_TCC4-1 nil 3652545389 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (min_y_val termination
    "acceptable_polygon.min_y_val(acceptable_polygon.N, acceptable_polygon.p, (number_fields.-)(acceptable_polygon.N, 1))"
    "nil")))
 (min_y_val_TCC5 0
  (min_y_val_TCC5-1 nil 3652545389
   ("" (skeep*)
    (("" (typepred "v(N,p,N-1)")
      (("1" (split)
        (("1" (skeep)
          (("1" (inst + "j")
            (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
          nil)
         ("2" (skeep) (("2" (inst - "j") (("2" (assert) nil nil)) nil))
          nil))
        nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil nil nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_y_val subtype
    "acceptable_polygon.min_y_val(acceptable_polygon.N, acceptable_polygon.p, (number_fields.-)(acceptable_polygon.N, 1))"
    "{r: reals.real | booleans.AND(EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.AND(reals.<(j, acceptable_polygon.N), r = acceptable_polygon.p(j)`y), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.<(j, acceptable_polygon.N), reals.>=(acceptable_polygon.p(j)`y, r)))}")))
 (min_y_val_TCC6 0
  (min_y_val_TCC6-1 nil 3652545389 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (min_y_val subtype "acceptable_polygon.i"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (min_y_val_TCC7 0
  (min_y_val_TCC7-1 nil 3652545389 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (min_y_val subtype "(number_fields.-)(acceptable_polygon.i, 1)"
    "nat")))
 (min_y_val_TCC8 0
  (min_y_val_TCC8-1 nil 3652545389 ("" (termination-tcc) nil nil) nil
   nil
   (min_y_val termination
    "acceptable_polygon.min_y_val(acceptable_polygon.N, acceptable_polygon.p, (number_fields.-)(acceptable_polygon.i, 1))"
    "nil")))
 (min_y_val_TCC9 0
  (min_y_val_TCC9-1 nil 3652545389
   ("" (skeep*)
    (("" (typepred "v(N,p,i-1)")
      (("1" (split +)
        (("1" (inst-cp + "i")
          (("1" (skeep)
            (("1" (inst + "j")
              (("1" (ground)
                (("1" (expand "min")
                  (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (case "j = i")
            (("1" (expand "min")
              (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)
             ("2" (inst -3 "j")
              (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_y_val subtype
    "real_defs.min(acceptable_polygon.p(acceptable_polygon.i)`y, acceptable_polygon.min_y_val(acceptable_polygon.N, acceptable_polygon.p, (number_fields.-)(acceptable_polygon.i, 1)))"
    "{r: reals.real | booleans.AND(EXISTS (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.AND(reals.<(j, acceptable_polygon.N), r = acceptable_polygon.p(j)`y), FORALL (j: naturalnumbers.upto(acceptable_polygon.i)): booleans.IMPLIES(reals.<(j, acceptable_polygon.N), reals.>=(acceptable_polygon.p(j)`y, r)))}")))
 (test_point_below_TCC1 0
  (test_point_below_TCC1-1 nil 3655210113 ("" (subtype-tcc) nil nil)
   nil nil
   (test_point_below subtype
    "(number_fields.-)(acceptable_polygon.N, 1)" "nat")))
 (counterclockwise_edges_TCC1 0
  (counterclockwise_edges_TCC1-1 nil 3652543392
   ("" (subtype-tcc) nil nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (counterclockwise_corner_index def-decl "{j: nat |
   j < N AND
    FORALL (z: below(N)):
      z <= i IMPLIES
       (eps * p(z)`x >= eps * p(j)`x AND
         (p(z)`x = p(j)`x IMPLIES p(z)`y >= p(j)`y))}"
     acceptable_polygon nil)
    (<= const-decl "bool" reals nil) (Sign type-eq-decl nil sign reals)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (- const-decl "[numfield -> numfield]" number_fields nil))
   nil
   (counterclockwise_edges subtype "acceptable_polygon.lprev"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (counterclockwise_edges_TCC2 0
  (counterclockwise_edges_TCC2-1 nil 3652543392
   ("" (subtype-tcc) nil nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield -> numfield]" number_fields nil) nil)
   nil
   (counterclockwise_edges subtype "acceptable_polygon.lnext"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (counterclockwise_edges_TCC3 0
  (counterclockwise_edges_TCC3-1 nil 3652543392
   ("" (subtype-tcc) nil nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (/= const-decl "boolean" notequal nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Sign type-eq-decl nil sign reals) (<= const-decl "bool" reals nil)
    (counterclockwise_corner_index def-decl "{j: nat |
   j < N AND
    FORALL (z: below(N)):
      z <= i IMPLIES
       (eps * p(z)`x >= eps * p(j)`x AND
         (p(z)`x = p(j)`x IMPLIES p(z)`y >= p(j)`y))}"
     acceptable_polygon nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil) nil)
   nil
   (counterclockwise_edges subtype "acceptable_polygon.rprev"
    "naturalnumbers.below(acceptable_polygon.N)")))
 (counterclockwise_edges_TCC4 0
  (counterclockwise_edges_TCC4-1 nil 3652543392
   ("" (subtype-tcc) nil nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Vect2 type-eq-decl nil vectors_2D_def vectors)
    (polygon_2D type-eq-decl nil acceptable_polygon nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield -> numfield]" number_fields nil) nil)
   nil
   (counterclockwise_edges subtype "acceptable_polygon.rnext"
    "naturalnumbers.below(acceptable_polygon.N)"))))

