winding_number__full: THEORY
BEGIN

  IMPORTING vectors_2D_fp_def,
  	    acceptable_polygon

  IMPORTING ints@tdiv

  X,Y: VAR unb_double

  quadrant(X,Y): int =
    IF    (RtoD(0) <= X) AND (RtoD(0) <= Y) THEN 1
    ELSIF (X <= RtoD(0)) AND (RtoD(0) <= Y) THEN 2
    ELSIF (X <= RtoD(0)) THEN 3
    ELSE 4
    ENDIF

  P_V1_x, P_V1_y, P_V2_x, P_V2_y, S_x, S_y, DET: VAR unb_double
  K,P: VAR int

  winding_number_contrib(P_V1_x,P_V1_y,P_V2_x,P_V2_y,S_x,S_y): int =
    LET THIS_x     = Dsub(P_V1_x,S_x) ,
        THIS_y     = Dsub(P_V1_y,S_y) ,
        NEXT_x     = Dsub(P_V2_x,S_x) ,
        NEXT_y     = Dsub(P_V2_y,S_y) ,
        DISTANCE_x = Dsub(NEXT_x,THIS_x) ,
        DISTANCE_y = Dsub(NEXT_y,THIS_y) ,
        DET        = Dsub(Dmul(DISTANCE_x,THIS_y),Dmul(DISTANCE_y,THIS_x)) ,
        K : int    = quadrant(THIS_x,THIS_y) ,
        P : int    = quadrant(NEXT_x,NEXT_y)
    IN IF    K = P THEN  0
       ELSIF P - 1 = mod.mod(K,4) THEN  1
       ELSIF K - 1 = mod.mod(P,4) THEN -1
       ELSIF DET <= RtoD(0)       THEN  2
       ELSE                            -2
       ENDIF

  winding_number_rec(N:posnat,p:polygon_2D_fp(N),s:Vect2_fp,i:below(N))
  : RECURSIVE int
  = LET next_i:below(N) = IF i<N-1 THEN i+1 ELSE 0 ENDIF,
      	contrib:int = winding_number_contrib
		        (p(i)`x,p(i)`y,p(next_i)`x,p(next_i)`y,s`x,s`y)
    IN IF i=0 THEN contrib
       ELSE winding_number_rec(N,p,s,i-1)+contrib
       ENDIF
  MEASURE i

  winding_number(N:posnat,p:polygon_2D_fp(N),s:Vect2_fp) : int
  = tdiv(winding_number_rec(N,p,s,N-1),4)

END winding_number__full
