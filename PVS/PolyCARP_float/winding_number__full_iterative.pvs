winding_number__full_iterative: THEORY
BEGIN

  IMPORTING float@ieee754dp_sub, float@ieee754dp_mul

  % floating-point vectors

  Vect2_fp: TYPE = [#  x, y: unb_double #]

  mk_vect2_fp(x,y:unb_double) : MACRO Vect2_fp =  (# x := x, y := y #) 
  CONVERSION mk_vect2_fp

  % acceptable_polygon

  polygon_2D_fp(N:posnat): TYPE = [below(N) -> Vect2_fp]

  % winding number

  IMPORTING ints@tdiv,
  	    structures@for_iterate

  X,Y: VAR unb_double

  quadrant(X,Y): int =
    IF    (RtoD(0) <= X) AND (RtoD(0) <= Y) THEN 1
    ELSIF (X <= RtoD(0)) AND (RtoD(0) <= Y) THEN 2
    ELSIF (X <= RtoD(0)) THEN 3
    ELSE 4
    ENDIF

  P_V1_x, P_V1_y, P_V2_x, P_V2_y, S_x, S_y, DET: VAR unb_double
  K,P: VAR int

  winding_number_contrib(P_V1_x,P_V1_y,P_V2_x,P_V2_y,S_x,S_y): int =
    LET THIS_x     = Dsub(P_V1_x,S_x) ,
        THIS_y     = Dsub(P_V1_y,S_y) ,
        NEXT_x     = Dsub(P_V2_x,S_x) ,
        NEXT_y     = Dsub(P_V2_y,S_y) ,
        DISTANCE_x = Dsub(NEXT_x,THIS_x) ,
        DISTANCE_y = Dsub(NEXT_y,THIS_y) ,
        DET        = Dsub(Dmul(DISTANCE_x,THIS_y),Dmul(DISTANCE_y,THIS_x)) ,
        K : int    = quadrant(THIS_x,THIS_y) ,
        P : int    = quadrant(NEXT_x,NEXT_y)
    IN IF    K = P THEN  0
       ELSIF P - 1 = mod.mod(K,4) THEN  1
       ELSIF K - 1 = mod.mod(P,4) THEN -1
       ELSIF DET <= RtoD(0)       THEN  2
       ELSE                            -2
       ENDIF

  winding_number_for(N:posnat,p:polygon_2D_fp(N),s:Vect2_fp,i:below(N))
  : int
  = for_down[int](N-1,0,0,
      LAMBDA(i:below(N),contribs_accumulation: int):
        LET next_i: below(N)   = IF i<N-1 THEN i+1 ELSE 0 ENDIF,
	    contrib: int       = winding_number_contrib
		                  (p(i)`x,p(i)`y,p(next_i)`x,p(next_i)`y,s`x,s`y)
	IN contribs_accumulation + contrib )

  winding_number(N:posnat,p:polygon_2D_fp(N),s:Vect2_fp) : int
  = tdiv(winding_number_for(N,p,s,N-1),4)
  

END winding_number__full_iterative
